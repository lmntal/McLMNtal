state_space.use.
set.use.

:- uniq| ret = val([[{n(5). chopstick(1). chopstick(2). chopstick(3). chopstick(4). chopstick(5). {phi(5). state(thinking). noOfSticks(0). }, {phi(4). state(thinking). noOfSticks(0). }, {phi(3). state(thinking). noOfSticks(0). }, {phi(2). state(thinking). noOfSticks(0). }, {phi(1). state(thinking). noOfSticks(0). }. }|0],[{n(5). chopstick(1). chopstick(2). chopstick(3). chopstick(4). chopstick(5). {phi(5). state(thinking). noOfSticks(0). }, {phi(4). state(thinking). noOfSticks(0). }, {phi(3). state(thinking). noOfSticks(0). }, {phi(2). state(thinking). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|0],[{n(5). chopstick(1). chopstick(2). chopstick(3). chopstick(4). chopstick(5). {phi(5). state(thinking). noOfSticks(0). }, {phi(4). state(thinking). noOfSticks(0). }, {phi(3). state(thinking). noOfSticks(0). }, {phi(2). state(hungry). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). chopstick(1). chopstick(2). chopstick(3). chopstick(4). chopstick(5). {phi(5). state(thinking). noOfSticks(0). }, {phi(4). state(thinking). noOfSticks(0). }, {phi(3). state(hungry). noOfSticks(0). }, {phi(2). state(hungry). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). chopstick(1). chopstick(2). chopstick(3). chopstick(4). chopstick(5). {phi(5). state(thinking). noOfSticks(0). }, {phi(4). state(hungry). noOfSticks(0). }, {phi(3). state(hungry). noOfSticks(0). }, {phi(2). state(hungry). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). chopstick(1). chopstick(2). chopstick(3). chopstick(4). chopstick(5). {phi(5). state(hungry). noOfSticks(0). }, {phi(4). state(hungry). noOfSticks(0). }, {phi(3). state(hungry). noOfSticks(0). }, {phi(2). state(hungry). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). chopstick(1). chopstick(2). chopstick(3). chopstick(4). {phi(5). state(hungry). noOfSticks(1). }, {phi(4). state(hungry). noOfSticks(0). }, {phi(3). state(hungry). noOfSticks(0). }, {phi(2). state(hungry). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). chopstick(1). chopstick(2). chopstick(3). {phi(5). state(hungry). noOfSticks(1). }, {phi(4). state(hungry). noOfSticks(1). }, {phi(3). state(hungry). noOfSticks(0). }, {phi(2). state(hungry). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). chopstick(1). chopstick(2). {phi(5). state(hungry). noOfSticks(1). }, {phi(4). state(hungry). noOfSticks(1). }, {phi(3). state(hungry). noOfSticks(1). }, {phi(2). state(hungry). noOfSticks(0). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). chopstick(1). {phi(5). state(hungry). noOfSticks(1). }, {phi(4). state(hungry). noOfSticks(1). }, {phi(3). state(hungry). noOfSticks(1). }, {phi(2). state(hungry). noOfSticks(1). }, {phi(1). state(hungry). noOfSticks(0). }. }|1],[{n(5). {phi(5). state(hungry). noOfSticks(1). }, {phi(4). state(hungry). noOfSticks(1). }, {phi(3). state(hungry). noOfSticks(1). }, {phi(2). state(hungry). noOfSticks(1). }, {phi(1). state(hungry). noOfSticks(1). }. }|1],[{n(5). {phi(5). state(hungry). noOfSticks(1). }, {phi(4). state(hungry). noOfSticks(1). }, {phi(3). state(hungry). noOfSticks(1). }, {phi(2). state(hungry). noOfSticks(1). }, {phi(1). state(hungry). noOfSticks(1). }. }|1]],
	     {
	hungry__ @@ {phi=I, state=thinking, $p} :- int(I) |
            {phi=I, state=hungry,   $p}.
	grab1stL @@ {phi=I, state=hungry,   noOfSticks=0}, chopstick(J) :- J=:=I |
            {phi=I, state=hungry,   noOfSticks=1}.
	grab1stR @@ {phi=I, state=hungry,   noOfSticks=0}, n(N), chopstick(J) :- J=:=I mod N + 1 |
            {phi=I, state=hungry,   noOfSticks=1}, n(N).
	grab2ndL @@ {phi=I, state=hungry,   noOfSticks=1}, chopstick(J) :- J=:=I |
            {phi=I, state=eating,   noOfSticks=2}.
	grab2ndR @@ {phi=I, state=hungry,   noOfSticks=1}, n(N), chopstick(J) :- J=:=I mod N + 1 |
            {phi=I, state=eating,   noOfSticks=2}, n(N).
	stopEat_ @@ {phi=I, state=eating,   noOfSticks=J}, n(N) :- int(J), C=(I mod N)+1 |
            {phi=I, state=thinking, noOfSticks=0}, n(N), chopstick(I), chopstick(C).
	     },
	     ba([0, 1], [d(0, true, 0), d(0, and(not(!P), !Q), 1), d(1, not(!P), 1)], [0], [1])),
pred({{phi(1), state(eating), '$s'}}, {}, !P),
pred({{phi(1), state(hungry), '$s'}}, {}, !Q).

% ------------------------------------------------------------------------------------------------------------------
% 入力: 反例、モデル、Buchiオートマトン
% 出力: 反例がBuchiオートマトンに受理され、かつモデルにも受理されるとき、まとそのときに限り"yes", それ以外の場合"no"

% 1.反例がBuchiオートマトンに受理される
% <=>反例中にループが1つ存在し、かつそのループ内のある状態を入力するとオートマトンが受理状態に遷移する
% 2.反例がモデルの(すべての状態を受理状態とする非決定性)オートマトンに受理される
% <=>反例のすべての遷移がモデルによって生成可能
% ------------------------------------------------------------------------------------------------------------------
Ret = val(Ce, {@r}, A) :- Ret = a(loop(v(Ce, {@r}), []), A).

% 
% Automaton
% 
Ret = a(ce([[S|I]|L], X), ba(Q, D, [$ini], Ac)) :- int($ini) |
    Ret = a_0(L, X, S, I, ba(Q, D, [$ini], Ac), $ini).

Ret = a_0(L, X, S, I, ba(Q, D, Ini, Ac), St) :-
    Ret = a_1(L, X, I, ba(Q, copy_props(D, D_), Ini, Ac), basucc(St, D_, S, [])).

Ret = a_1([[S|I]|L], X, $i, A, [N]) :- int($i) |
    Ret = a_0(L, X, S, I, A, N).


copy_props([], D1, D2) :-
    D1 = [], D2 = [].
copy_props([d($src, P, $dst) | T], D1, D2) :- int($src), int($dst) |
    D1 = [d($src, P1, $dst) | T1], D2 = [d($src, P2, $dst) | T2],
    copy_prop(P, P1, P2), copy_props(T, T1, T2).

copy_prop(true, P1, P2) :-
    P1 = true, P2 = true.
copy_prop(false, P1, P2) :-
    P1 = false, P2 = false.
copy_prop(not(X), P1, P2) :-
    P1 = not(L1), P2 = not(L2),
    copy_prop(X, L1, L2).
copy_prop($x, P1, P2) :- hlink($x) |
    P1 = $x, P2 = $x.
copy_prop(and(X, Y), P1, P2) :-
    P1 = and(L1, L2), P2 = and(L1_, L2_),
    copy_prop(X, L1, L1_),
    copy_prop(Y, L2, L2_).
copy_prop(or(X, Y), P1, P2) :-
    P1 = not(and(not(L1), not(L2))), P2 = not(and(not(L1_), not(L2_))),
    copy_prop(X, L1, L1_),
    copy_prop(Y, L2, L2_).
copy_prop(imply(X, Y), P1, P2) :-
    P1 = not(and(L1, not(L2))), P2 = not(and(L1_, not(L2_))),
    copy_prop(X, L1, L1_),
    copy_prop(Y, L2, L2_).


delete_prop(true) :- .
delete_prop(false) :- .
delete_prop(not(X)) :- delete_prop(X).
delete_prop($x) :- hlink($x) | .
delete_prop(and(X, Y)) :- delete_prop(X), delete_prop(Y).
delete_prop(or(X, Y)) :- delete_prop(X), delete_prop(Y).
delete_prop(imply(X, Y)) :- delete_prop(X), delete_prop(Y).


% basucc----------------------------------------------------------------------
Ret = basucc($q, [d($n, F, $nn)|T], {$s[]}, RetS) :-
    $n=:=$q, int($nn) |
    Ret = basucc($q, T, {$s[]}, RetS, inner_basucc(F, {$s[]}, $nn)).

Ret = basucc($q, [d($n, F, $nn)|T], S, RetS) :-
    $q =\= $n, int($nn) |
    Ret = basucc($q, T, S, RetS), delete_prop(F).

Ret = basucc($q, [], {$s[]}, RetS) :-
    int($q) |
    Ret = RetS.

Ret = basucc(Q, D, S, RetS, true(N)) :-
    Ret = basucc(Q, D, S, [N|RetS]).

Ret = basucc(Q, D, S, RetS, fail($n)) :-
    int($n) |
    Ret = basucc(Q, D, S, RetS).

% inner_basucc----------------------------------------------------------------------
Ret = inner_basucc(and(X, Y), {$s[]}, $n) :- int($n) |
    Ret = and_inner_basucc(inner_basucc(X, {$s[]}, $n), inner_basucc(Y, {$s[]}, $n)).

Ret = and_inner_basucc(true($n), true($m)) :- int($n), int($m) |
    Ret = true($n).
Ret = and_inner_basucc(true($n), fail($m)) :- int($n), int($m) |
    Ret = fail($n).
Ret = and_inner_basucc(fail($n), true($m)) :- int($n), int($m) |
    Ret = fail($n).
Ret = and_inner_basucc(fail($n), fail($m)) :- int($n), int($m) |
    Ret = fail($n).

Ret = not(true(N)) :-
	Ret = fail(N).
Ret = not(fail(N)) :-
	Ret = true(N).

Ret = inner_basucc(not(X), S, N) :-
	Ret = not(inner_basucc(X, S, N)).

Ret = inner_basucc($x, S, N), pred({$h[]}, {$g[]}, $y) :- hlink($x), $x == $y |
    Ret = t_inner_basucc(state_space.react_nd_set({':-'({$h[]}, {$g[]}, {$h[]})}, S, p($x)), N).

Ret = inner_basucc($x, S, N), p($y) = Pred :- hlink($x), $x == $y |
    Ret = t_inner_basucc(state_space.react_nd_set(Pred, S, p($x)), N).

Ret = inner_basucc(true, {$s[]}, N) :-
    Ret = true(N).

Ret = inner_basucc(false, {$s[]}, N) :-
    Ret = fail(N).

Ret = t_inner_basucc([], N) :-
    Ret = fail(N).
Ret = t_inner_basucc([{$g[]}|T], N) :-
    Ret = true(N), free(T).

% 
% Loop
% 

Ret = loop(true([[{$s[]}|$i]|L]), X) :- int($i) |
    Ret = lo(L, l(F, B), set.insert(set.init, $i), X), '.'([{$s[]}|$i], B, F).

Ret = lo([[S|$i]|L], R, Set, X) :- int($i) |
    Ret = lo_0([[S|$i]|L], R, set.find(Set, $i, Rs), Rs, X).
Ret = lo([], l(F, B), Set, [X]):- 
    Ret = ce(F, X), B=[], set.free(Set).

Ret = lo_0([[{$s[]}|$i]|L], l(F, B), Set, none, X_), '.'(X, B_, F_), B=B_ :- int($i) |
    Ret = lo(L, l(F, B), set.insert(Set, $i), X_), '.'(X, B_, F_), '.'([{$s[]}|$i], B, B_).
Ret = lo_0([[{$s[]}|$i]|L], l(F, B), Set, some, X_), '.'(X, B_, F_), B=B_ :- int($i) |
    Ret = lo(L, l(F, B), Set, [$i|X_]), '.'(X, B_, F_), '.'([{$s[]}|$i], B, B_).


% 
% Model
% 

del([{$s[]}|L]) :- del(L).
del([]) :- .

Ret = v([[{$s[]}|$x]|L], Rs) :- int($x) | 
    Ret = run({$s[]}, L, Rs, state_space.state_map_find(state_space.state_map_init, {$s[]}, I), l(F, B)), '.'([{$s[]}|I], B, F).

Ret = run({$s[]}, [[{$dst[]}|$x]|L], Rs, M, R_) :- int($x) | 
    Ret = run_({$s[]}, {$dst[]}, I, L, Rss, state_space.react_nd_set(Rs, {$s[]}, Rss), state_space.state_map_find(M, {$dst[]}, I), R_).
Ret = run({$s[]}, [], {@r}, M, l(F, B)) :- Ret = true(F), B=[], free(M).

Ret = run_({$s[]}, D, I, L, Rs, [D_|LL], M, R_) :- 
    Ret = run_0(D, I, L, Rs, [D_|LL], M, R_).
% stutter extension
Ret = run_({$s[]}, D, I, L, Rs, [], M, R_) :- 
    Ret = run_0(D, I, L, Rs, [{$s[]}], M, R_).

Ret = run_0(D, I, L, Rs, [{$d[]}|LL], M, R_) :- 
    Ret = run_1(D, I, L, Rs, LL, I_, state_space.state_map_find(M, {$d[]}, I_), R_).
Ret = run_0(D, I, L, Rs, [], M, R_) :- 
    Ret = false(D, I, L, Rs, M, R_).

Ret = run_1({$d[]}, $i, L, Rs, LL, $i_, M, l(F, B)), '.'(X, B_, F_), B=B_ :- $i=$i_ | 
    Ret = run({$d[]}, L, Rs, M, l(F, B)), '.'(X, B_, F_), '.'([{$d[]}|$i], B, B_), del(LL).
Ret = run_1(D, $i, L, Rs, LL, $i_, M, R_) :- $i=\=$i_ | Ret = run_0(D, $i, L, Rs, LL, M, R_).


